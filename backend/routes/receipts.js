const express = require('express');
const router = express.Router();
const fake_receipt = require("../data/migros-receipt.json");
const index = require('../utils/indexation');
const connect_db = require("../utils/dbconn");
const { ObjectId} = require("mongodb");
const products = require("../data/migros.json");


/* Test route to test indexaction algorithm */
router.get('/test',async (req,res,next)=>{
  const receipt = fake_receipt;
  const result = []
    
  result.push(index.test("Triple",index.triple_jaro_levenshtei_dice_price,receipt,products,false))
  
  res.status(200).json(result);
})

/* Post new receipts */
router.post('/', async (req, res, next) => {

  if (!req.body.receipt) {
    res.status(400).json({
      error: "Empty body"
    })
    return;
  }

  if (!req.body.receipt.products.length) {
    res.status(400).json({
      error: "No products in receipt"
    })
    return;
  }
  //Remove _id because it is generated by MongoDB on insert
  if(req.body.receipt._id){
    delete req.body.receipt._id;
  }

  const receipt = req.body.receipt;

  const db = await connect_db();
  const products_collection = db.collection("products_"+receipt.shop_name);
  const acronyms_collection = db.collection("acronyms");

  let indexed_product = []
  let total = 0;
  for (let receipt_product of receipt.products) {
    total += receipt_product.total_price;
    let found_product;
    //Searching in the acronym document if the product is already indexed
    const indexed_acronym = await acronyms_collection.findOne({
      acronym:receipt_product.product_name
    })
    //If the product is already indexed we just retrive the product
    //Otherwise we get all products that match the price and index it
    if(indexed_acronym != null){
      found_product = await products_collection.findOne({
        _id: indexed_acronym.product_id
      });
    }else{
      const products = await products_collection.find({
        $or: [
          { actual_price: 0 },
          { actual_price: receipt_product.unit_price }
        ]
      }).toArray();
      //Running the algorithm to match the best product
      found_product = index.run(receipt_product, products);
      //Once we find the best match, we save it in the acronym document so we don't need
      // to reindex it 
      acronyms_collection.insertOne({
        acronym:receipt_product.product_name,
        product_id: found_product._id
      })
    }
    
    receipt_product.product_name = found_product.name;
    receipt_product.category= found_product.category;

    indexed_product.push(receipt_product);
  }
  receipt.products = indexed_product;
  receipt.total = parseFloat(total.toFixed(2));
  receipt.date = new Date(receipt.date);

  //Saving the receipt in the database
  const receipt_collection = db.collection("receipts");
  receipt_collection.insertOne(receipt);

  res.status(200).json({
    receipt
  });
});
/* GET a receipt with products by id*/
router.get('/:id', async (req, res, next) => {
  const db = await connect_db();
  const receipts_collection = db.collection("receipts");
  let receipt;


  try {
    receipt = await receipts_collection.findOne({
      _id: new ObjectId(req.params.id)
    });
  } catch (e) {
    res.status(404).json({
      error: "Receipt not found"
    });
    return;
  }

  res.status(200).json({
    receipt
  });


})
/* Get a all recipes */
router.get('/', async (req, res, next) => {
  
  const db = await connect_db();
  const receipts_collection = db.collection("receipts");
  const receipts = await receipts_collection.find({},
    {
      projection: {
        _id: 1,
        total: 1,
        date:1,
        shop_name: 1,
      }
    }).toArray();


  res.status(200).json({
    receipts
  });
});


module.exports = router;
